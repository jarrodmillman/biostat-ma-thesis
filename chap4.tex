\chapter{\label{ch:nextsteps}Next steps}

While the development of \texttt{permute} will continue to be guided by the
scientific projects we engage with, there are a few things already planned.

\section{\label{sec:book}``Permutation Tests for Complex Data'' Examples}

On the companion
website\footnote{\url{http://www.wiley.com/legacy/wileychi/pesarin/material.html}}
to ``Permutation Tests for Complex Data: Theory, Applications and
Software'' by F. Pesarin and L. Salmaso \cite{pesarin2010permutation}, the
authors provide several R functions for implementing the application examples
presented in their book.  They've also made their datasets available for download
(as well as some Matlab and SAS code).  In preparation for the second edition,
we will be implementing these examples in Python as part of our package.

As mentioned above, these datasets are already included in our package.  We've
also created a GitHub
repository,\footnote{\url{https://github.com/statlab/permuter}} where we've
made some tentative improvements to the code.  In order to create a test suite
to ensure we are able to independently produce the results given by the R
implementation, we plan to develop it into a simple R package.  Since the
existing R code was released for the purpose of illustration, rather than as an
attempt by the authors to provide an R library for reuse, we do not currently
plan to submit the package to CRAN.  However, it will be publicly-available on
GitHub and will be easily installable (we will need to make it easy to install
for the purposes of our automated testing anyway).

In addition to using the examples and R code as part of our testing suite, we
will also include a detailed discussion of each example from the book in our
user documentation.  While our intention is not to further develop and improve
the R package, we will fix bugs and refactor the code as necessary to ensure
that we can validate our results for the examples using \texttt{permute} with
an independent implementation in R.  As part of our documentation we will
include snippets of the R code, in the hopes that it might serve users of
\texttt{permute} who are more familiar with R as they work through the examples
in Python.

%\section{Missing functionality}
%
%
%\subsection{Problems/Methods}
%
%The 2-sample problem
%
%The n-sample problem
%
%Tests for the slope in linear regression 
%
%Tests for quantiles
%
%Tests of independence and association: runs tests, permutation association, ...
%
%Tests of exchangeability
%
%Tests of symmetry: reflection, spherical, ...
%
%Permutation ANOVA
%
%Goodness of fit tests
%
%
%\subsection{Confidence sets}
%
%Constant shifts
%
%Proportional shifts
%
%Monotone shifts

\section{Missing features and new projects}

As time permits, we will also start adding functionality to round out the
diversity of permutation tests we provide.  For example, adding tests for slope
in linear regression, for independence and association (e.g., runs tests), or
for symmetry will be easy to do once we have a better sense of how we will
ultimately organize our modules and subpackages.  Even without motivating
scientific collaborations, we will want to start adding these tests and their
associated confidence sets as it will help us refine our naming and call
signature conventions.

While our motivating scientific collaborations have so far produced small- to
moderate-sized datasets, I would like to start looking at larger datasets.  In
particular, I would like to begin applying our software to problems from
genomics and functional neuroimaging.  Both of these problem domains already
make use of permutation tests and the size of the datasets will enable to
seriously focus on scalability issues.  

\section{Design decisions}

In the interest of making incremental improvements while gaining experience
with the problem domain and implementation details in Python, we have postponed
making decisions regarding several important design choices. However, as we
continue to add new functionality and expanding our codebase, these choices
will need to be made.

The Python language is in the middle of major transition from version 2 to
3.  Version 3 introduced several changes, which broke backward compatibility.
Given the large deployed codebase already written in Python, the transition
is a slow multiyear process.  We are currently committed to maintaining one
codebase that runs without modification on both Python 2 and 3.  Our testing
infrastructure ensures that we are continually checking that our code works
on both platforms.  When there are problems, we are immediately notified and
can quickly resolve the problem.  However, supporting Python 2 requires that
we avoid using new features provided by Python 3.  Since we haven't yet
attracted a user base, we may want to drop support for Python 2 before
too long.

Python is known for its extensive standard library; however, few scientific
libraries are included as part of the standard library.  So far we have
restricted our core dependencies on third-party packages to NumPy and SciPy.
As we add new functionality, we will be tempted to leverage additional
external packages.  For pure Python packages, this will cause little
difficulty.  However, many of the packages we will be interested in
are partially implemented in C or another compiled language.  Depending
on packages that require compilation, will increase the complexity
of installation for some users.

While choosing which versions of Python to support and what packages to depend
on will require some thought, a more difficult set of questions will arise as
we attempt to finalize our application programming interface (API).  We've
already spent a lot of effort unifying our call signatures and naming
conventions.  However, we have begun discussing a more generic structures for
specifying test statistics.  At the very least, we would like to be able to
pass functions, rather than using strings as we currently do.  If we go this
route it may make sense to consider creating test statistics classes that
we can instantiate with the test statistic function.  A more interesting
possibility would be to see if we can create something like R's formula
for specifying our permutation models.

Finally, as we start implementing more tests and applying our package
to larger datasets, we will need to take performance more seriously.
While we've been able to stick to a pure Python implementation so far,
we will eventual need to write C extensions or use something like
Cython to improve computation time.  As permutation tests are inherently
parallelizable, we will also need to consider providing parallel processing
support.
